--- basic_splash_drm.c	2022-12-29 16:05:12.620890336 +0530
+++ basic_splash_drm_latest.c	2022-12-29 16:05:12.592890028 +0530
@@ -27,7 +27,6 @@
 
 #include "image_header.h"
 
-
 #define SPLASH_FIFO "/tmp/splash_fifo"
 
 #define MAX_HEIGHT_THRESHOLD 720
@@ -37,6 +36,188 @@
 static int pipe_fd;
 static int wait = 0;
 
+
+// -----------------@ Deepak ---------------------
+
+#define RECT_WIDTH      500         // Pixels
+#define RECT_HEIGHT     10
+#define RECT_X          262
+#define RECT_Y          688
+#define TEXT_SIZE_X     9
+#define TEXT_SIZE_Y     12
+#define TEXT_X          728
+#define TEXT_Y          658
+#define PERCENT_X     14
+#define PERCENT_Y     11
+
+uint8_t percent[11][14] = 
+{{0,1,1,1,1,0,0,0,0,1,0,0,0,0},
+{0,1,0,0,1,0,0,0,1,1,0,0,0,0},
+{0,1,0,0,1,1,0,0,1,0,0,0,0,0},
+{0,1,0,0,1,1,0,1,1,0,0,0,0,0},
+{0,1,0,0,1,0,0,1,0,1,1,1,0,0},
+{0,1,1,1,1,0,1,0,1,1,0,1,1,0},
+{0,0,0,1,0,1,1,0,1,0,0,1,1,0},
+{0,0,0,0,0,1,0,0,1,0,0,1,1,0},
+{0,0,0,0,1,1,0,0,1,0,0,1,1,0},
+{0,0,0,0,1,0,0,0,1,1,0,1,1,0},
+{0,0,0,1,1,0,0,0,0,1,1,1,0,0}};
+
+uint8_t number_to_pix[][TEXT_SIZE_Y][TEXT_SIZE_X] = 
+{
+{{0,0,0,0,1,0,0,0,0},
+{0,0,1,1,1,1,1,0,0},
+{0,1,1,0,0,0,1,1,0},
+{0,1,1,0,0,0,1,1,0},
+{0,1,1,0,0,0,0,1,0},
+{0,1,0,0,0,0,0,1,0},
+{0,1,0,0,0,0,0,1,0},
+{0,1,0,0,0,0,0,1,0},
+{0,1,1,0,0,0,0,1,0},
+{0,1,1,0,0,0,1,1,0},
+{0,0,1,1,0,1,1,1,0},
+{0,0,1,1,1,1,1,0,0}},
+
+{{0,0,0,1,1,1,0,0,0},
+{0,0,1,1,1,1,0,0,0},
+{0,0,1,0,1,1,0,0,0},
+{0,0,0,0,1,1,0,0,0},
+{0,0,0,0,1,1,0,0,0},
+{0,0,0,0,1,1,0,0,0},
+{0,0,0,0,1,1,0,0,0},
+{0,0,0,0,1,1,0,0,0},
+{0,0,0,0,1,1,0,0,0},
+{0,0,0,0,1,1,0,0,0},
+{0,0,0,0,1,1,0,0,0}},
+
+{{0,0,0,0,1,0,0,0,0},
+{0,1,1,1,1,1,1,0,0},
+{0,1,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,0,0},
+{0,0,0,0,0,1,1,0,0},
+{0,0,0,0,1,1,0,0,0},
+{0,0,0,1,1,0,0,0,0},
+{0,0,1,1,0,0,0,0,0},
+{0,1,1,1,1,1,1,1,0},
+{0,1,1,1,1,1,1,1,0}},
+
+{{0,0,0,1,1,0,0,0,0},
+{0,1,1,1,1,1,1,0,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,1,1,1,1,0,0},
+{0,0,0,1,1,1,1,0,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,1,0,0,0,1,1,1,0},
+{0,1,1,1,1,1,1,0,0}},
+
+{{0,0,0,0,0,1,1,0,0},
+{0,0,0,0,1,1,1,0,0},
+{0,0,0,0,1,0,1,0,0},
+{0,0,0,1,0,0,1,0,0},
+{0,0,1,1,0,0,1,0,0},
+{0,1,1,0,0,0,1,0,0},
+{0,1,0,0,0,0,1,0,0},
+{1,1,1,1,1,1,1,1,1},
+{0,0,0,0,0,1,1,1,0},
+{0,0,0,0,0,0,1,0,0},
+{0,0,0,0,0,0,1,0,0}},
+
+{{0,0,1,1,1,1,1,1,0},
+{0,1,1,0,0,0,0,0,0},
+{0,1,1,0,0,0,0,0,0},
+{0,1,1,0,0,0,0,0,0},
+{0,1,1,1,1,1,1,0,0},
+{0,0,0,0,0,1,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,0,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,1,0,0,0,1,1,1,0},
+{0,1,1,1,1,1,1,0,0}},
+
+{{0,0,0,0,0,1,1,0,0},
+{0,0,0,1,1,1,1,1,0},
+{0,0,1,1,0,0,0,0,0},
+{0,1,1,0,0,0,0,0,0},
+{0,1,1,0,0,0,0,0,0},
+{0,1,1,1,1,1,1,0,0},
+{0,1,1,1,0,0,1,1,0},
+{0,1,1,0,0,0,0,1,0},
+{0,1,1,0,0,0,0,1,0},
+{0,1,1,0,0,0,0,1,0},
+{0,0,1,1,0,0,1,1,0},
+{0,0,0,1,1,1,1,0,0}},
+
+{{0,1,1,1,1,1,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,0,0},
+{0,0,0,0,0,1,1,0,0},
+{0,0,0,0,0,1,0,0,0},
+{0,0,0,0,1,1,0,0,0},
+{0,0,0,0,1,0,0,0,0},
+{0,0,0,1,1,0,0,0,0},
+{0,0,0,1,1,0,0,0,0},
+{0,0,1,1,0,0,0,0,0}},
+
+{{0,0,0,0,1,0,0,0,0},
+{0,0,1,1,1,1,1,0,0},
+{0,1,1,0,0,0,1,1,0},
+{0,1,1,0,0,0,1,1,0},
+{0,1,1,0,0,0,1,1,0},
+{0,0,1,1,1,1,1,0,0},
+{0,0,1,1,1,1,1,0,0},
+{0,1,1,0,0,0,1,1,0},
+{0,1,0,0,0,0,0,1,0},
+{0,1,0,0,0,0,0,1,0},
+{0,1,1,0,0,0,1,1,0},
+{0,0,1,1,1,1,1,0,0}},
+
+{{0,0,0,0,1,0,0,0,0},
+{0,0,1,1,1,1,1,0,0},
+{0,1,1,0,0,0,1,1,0},
+{0,1,1,0,0,0,1,1,0},
+{0,1,0,0,0,0,0,1,0},
+{0,1,1,0,0,0,1,1,0},
+{0,1,1,1,1,1,1,1,0},
+{0,0,0,1,1,0,0,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,0,1,1,0},
+{0,0,0,0,0,1,1,0,0},
+{0,0,1,1,1,1,0,0,0}},
+};
+
+int old_progress = 0;
+
+// ------------ @ Deepak -end ------------------------------
+
+// ------------ @ Deepak Func Proto ------------------------
+
+void splash_draw_progress_bar(
+    int progress, 
+    uint8_t color_red, 
+    uint8_t color_green, 
+    uint8_t color_blue);
+
+void splash_draw_rectangle (
+        int x,
+        int y,
+        int rect_width,
+        int rect_height,
+        uint8_t c_r, uint8_t c_g, uint8_t c_b);
+
+void splash_draw_progress_text(int x, int y, uint8_t value[TEXT_SIZE_Y][TEXT_SIZE_X] , int red_text, int green_text, int blue_text);    
+void splash_draw_progress_percent(int x, int y, uint8_t value[PERCENT_Y][PERCENT_X] , int red_text, int green_text, int blue_text);
+// ------------ @ Deepak - End ---------------------------
+
+
+
+
 //----------------------
 // Prototype
 struct modeset_dev;
@@ -500,6 +681,9 @@
     }
 }
 
+
+
+
 //-------------------------------
 // Exit function
 void
@@ -524,7 +708,7 @@
     command = strtok(string," ");
 
     if (!strcmp(command,"PROGRESS")) {
-        //psplash_draw_progress (fb, atoi(strtok(NULL,"\0")));
+        splash_draw_progress_bar (atoi(strtok(NULL,"\0")), 0xff, 0xff, 0xff); //@deepak progress bar
     }
     else if (!strcmp(command,"MSG")) {
         //psplash_draw_msg (fb, strtok(NULL,"\0"));
@@ -596,6 +780,167 @@
     return;
 }
 
+// -------------------- @ Deepak - Functions ----------------
+void splash_draw_progress_bar(int progress, uint8_t color_red, uint8_t color_green, uint8_t color_blue)
+{
+
+    int a,x_step,n_step;
+    uint8_t old_percent = 0;
+    uint8_t percent_progress =0;
+    uint8_t data1=0;
+    uint8_t data2=0;
+
+
+    if(progress > 100){ //progress time in milli seconds
+        // boot time is sent instead of progress
+        n_step = RECT_WIDTH;
+        x_step = (RECT_WIDTH/n_step);    // for 1 pixels at a time
+        
+        //draw "  0%"
+        splash_draw_progress_text((TEXT_X+TEXT_SIZE_X*2), TEXT_Y, number_to_pix[0], 0xff, 0xff, 0xff); //0
+        splash_draw_progress_percent((TEXT_X+TEXT_SIZE_X*3), TEXT_Y, percent, 0xff, 0xff, 0xff); //percent
+        
+        for(a=RECT_X;a<(RECT_X+RECT_WIDTH);a+=x_step){
+            
+            // draw progress text after evert %
+            percent_progress = ((a-RECT_X+1)*100)/(RECT_WIDTH);
+
+            splash_draw_rectangle (a, RECT_Y, x_step, RECT_HEIGHT, color_red, color_green, color_blue);
+            
+            if((percent_progress>old_percent) && percent_progress <=96){
+
+                old_progress = percent_progress;    // for Progrss loop 
+                data1 = (percent_progress%10);
+                splash_draw_progress_text((TEXT_X+TEXT_SIZE_X*2), TEXT_Y, number_to_pix[data1], 0xff, 0xff, 0xff);
+                if((percent_progress>=10)&&(percent_progress<100)){
+                    data2 = (percent_progress/10);
+                    splash_draw_progress_text((TEXT_X+TEXT_SIZE_X), TEXT_Y, number_to_pix[data2], 0xff, 0xff, 0xff);
+                }
+                if(percent_progress==100){
+                    splash_draw_progress_text((TEXT_X+TEXT_SIZE_X), TEXT_Y, number_to_pix[0], 0xff, 0xff, 0xff);
+                    splash_draw_progress_text((TEXT_X), TEXT_Y, number_to_pix[1], 0xff, 0xff, 0xff);
+                }
+                old_percent = percent_progress;
+            }
+            if(percent_progress >=96) return;
+            usleep((progress*800)/n_step);
+        }
+
+    }
+    else
+    {
+        if((progress - old_progress)>0){
+            // if only progress percent is given then go from n-1 to n taking n_step
+            n_step = (progress-old_progress)*RECT_WIDTH/100.0;
+            x_step = ((RECT_WIDTH*(progress- old_progress)/100.0)/n_step);    // for 1 % at a time
+
+            // check if old_progress is zero to fill % sign
+            if(old_progress==0) splash_draw_progress_percent((TEXT_X+TEXT_SIZE_X*3), TEXT_Y, percent, 0xff, 0xff, 0xff); //percent
+
+            for(a=(RECT_X+(old_progress*RECT_WIDTH/100.0));a<(RECT_X+(progress*RECT_WIDTH/100.0));a+=x_step){
+
+                // draw progress text after evert %
+                percent_progress = ((a-RECT_X+1)*100)/(RECT_WIDTH);
+                if(percent_progress- old_percent > 0)
+                {
+                    data1 = (percent_progress%10);
+                    splash_draw_progress_text((TEXT_X+TEXT_SIZE_X*2), TEXT_Y, number_to_pix[data1], 0xff, 0xff, 0xff);
+                    if((percent_progress>=10)&&(percent_progress<100)){
+                        data2 = (percent_progress/10);
+                        splash_draw_progress_text((TEXT_X+TEXT_SIZE_X), TEXT_Y, number_to_pix[data2], 0xff, 0xff, 0xff);
+                    }
+                    if(percent_progress==100){
+                        splash_draw_progress_text((TEXT_X+TEXT_SIZE_X), TEXT_Y, number_to_pix[0], 0xff, 0xff, 0xff);
+                        splash_draw_progress_text((TEXT_X), TEXT_Y, number_to_pix[1], 0xff, 0xff, 0xff);
+                    }
+                    old_percent = percent_progress;
+                }
+                splash_draw_rectangle (a, RECT_Y, x_step, RECT_HEIGHT, color_red, color_green, color_blue);
+                usleep(2000);
+            }
+            old_progress = progress;
+        }
+    }
+
+    return;
+}
+
+// Draw function
+void splash_draw_rectangle (
+        int x,
+        int y,
+        int rect_width,
+        int rect_height,
+        uint8_t c_r, uint8_t c_g, uint8_t c_b)
+{
+    struct modeset_dev *iter;
+    uint8_t r, g, b;
+    unsigned int j, k, off;
+
+    r = c_r & 0xff;
+    g = c_g & 0xff;
+    b = c_b & 0xff;
+
+    for (iter = modeset_list; iter; iter = iter->next) {
+        for (j = y; j < (y+rect_height); ++j) {
+            for (k = x; k < (x+rect_width); ++k) {
+                off = iter->stride * j + k * 4;
+                *(uint32_t *) & iter->map[off] = (r << 16) | (g << 8) | b;
+            }
+        }
+    }
+
+    return;
+}
+
+void splash_draw_progress_text(int x, int y, uint8_t value[TEXT_SIZE_Y][TEXT_SIZE_X] , int red_text, int green_text, int blue_text){
+
+    struct modeset_dev *iter;
+    uint8_t r, g, b;
+    unsigned int j, k, off;
+
+    r = red_text & 0xff;
+    g = green_text & 0xff;
+    b = blue_text & 0xff;
+
+    for (iter = modeset_list; iter; iter = iter->next) {
+
+        for (j = y; j < (y+TEXT_SIZE_Y); ++j) {
+            for (k = x; k < (x+TEXT_SIZE_X); ++k) {
+                off = iter->stride * j + k * 4;
+                if(value[j-y][k-x]==1) *(uint32_t *) & iter->map[off] = (r << 16) | (g << 8) | b;
+                else *(uint32_t *) & iter->map[off] = 0;
+            }
+        }
+    }
+
+}
+void splash_draw_progress_percent(int x, int y, uint8_t value[PERCENT_Y][PERCENT_X] , int red_text, int green_text, int blue_text){
+
+    struct modeset_dev *iter;
+    uint8_t r, g, b;
+    unsigned int j, k, off;
+
+    r = red_text & 0xff;
+    g = green_text & 0xff;
+    b = blue_text & 0xff;
+
+    for (iter = modeset_list; iter; iter = iter->next) {
+
+        for (j = y; j < (y+PERCENT_Y); ++j) {
+            for (k = x; k < (x+PERCENT_X); ++k) {
+                off = iter->stride * j + k * 4;
+                if(value[j-y][k-x]==1) *(uint32_t *) & iter->map[off] = (r << 16) | (g << 8) | b;
+                else *(uint32_t *) & iter->map[off] = 0;
+            }
+        }
+    }
+
+}
+
+
+// ------------------- @ Deepak - End -----------------------
+
 //-------------------------------
 // Main function
 int
@@ -671,9 +1016,14 @@
     }
 
     /* draw some colors for 5seconds */
-    modeset_draw_bgcolor (0xFF, 0xFF, 0xFF);
-    splash_draw_image_center ();
+    //modeset_draw_bgcolor (0x00, 0x00, 0x00); //@deepak changed from 0xffffff to 0x000000
+    splash_draw_image_center (); // @deepak draw actual image
+
+    // If argument is "/usr/bin/psplash-drm -w -t 5000" 5000 mSec 
 
+    if (argc > 3)
+        if (!strncasecmp(argv[2], "-t",2))
+            splash_draw_progress_bar (atoi(argv[3]), 0xff, 0xff, 0xff); //@deepak progress bar
     splash_processing ();
 
     /* cleanup everything */
